# -*- coding: utf-8 -*-
"""RunningSafetyMargins.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1UgknYhxVzHOfX6MfGRMTYXrAqF-1SRF_

# Competitiveness

---

## Overview
Safety margins of team offensive output versus defensive ability.

##Set-up Environment
"""

#@title Provide Google Credentials to Colab Runtime
from google.colab import auth
auth.authenticate_user()
print('Authenticated')

#@title Install Latest Version of Plotly, for Use in Interactive Graphic
!pip install plotly -q --upgrade

#@title Enter BigQuery Project ID for Client
project_id = 'stardust-analysis' #@param{type:"string"}

from google.cloud import bigquery

!gcloud config set project 'stardust-analysis'

client = bigquery.Client(project = project_id)

#@title Import Python Libraries & Some Other Setup
# Basic Python data science libraries
import pandas as pd
import numpy as np
import scipy.stats
from collections import Counter
import matplotlib.pyplot as plt

# Import linear model and pre-processing modules from scikit-learn
from sklearn import linear_model, preprocessing

# Import warnings package, set to suppress warnings throughout this Colab
import warnings
warnings.simplefilter("ignore")

# Import and setup for Plotly in Colab, including function to be called later
import plotly.plotly as py

import plotly.graph_objs as go
from plotly.offline import download_plotlyjs, init_notebook_mode, plot, iplot

def enable_plotly_in_cell():
  import IPython
  from plotly.offline import init_notebook_mode
  display(IPython.core.display.HTML('''
        <script src="/static/components/requirejs/require.js"></script>
  '''))
  init_notebook_mode(connected=False)

"""## Code"""

#@title Basic function to calculate how safe a lead is at any given time - http://starbridgepartners.com/2014/03/when-is-a-college-basketball-game-statistically-over-bill-james-knows/#.WE3etaIrLKI
def safe_lead(score_differential, winning_team, possession_team, elapsed_time):
  '''
  @param
    score_differential is the difference between home and away points
    winning_team is the id of the current winning team
    possession_team is the id of the team currently with the ball
      - identify using filtered queries based on defensive rebounds
    elapsed_time is in seconds
  @return
    boolean value - whether or not the game has been decided
  '''
  remaining_time = 2400 - elapsed_time
  safety_margin = score_differential - 3
  if (winning_team == possession_team):
    safety_margin += 0.5
  else:
    safety_margin -= 0.5
  return ((safety_margin ** 2) > remaining_time)

# Estimates how long the lead can be held for in seconds
def safe_margin(score_differential, winning_team, possession_team):
  safety_margin = score_differential - 3
  if (winning_team == possession_team):
    safety_margin += 0.5
  else:
    safety_margin -= 0.5
  return (safety_margin ** 2)

game_id = "1004-17-2017-11-19" #@param{type: "string"}
games = client.query(
  """
  WITH pbp_box_stats AS(
SELECT
  season,
  pbp.game_id,
  game.team_code AS home_id,
  home_team,
  game.opp_code AS away_id,
  away_team,
  pbp.team_code AS event_team_id,
  event_type,
  pbp.period,
  elapsed_time_sec,
  SUM(IF(is_home = 1 AND event_type = "GOOD" AND NOT three_point_shot, 1, 0)) OVER 
  (PARTITION BY pbp.game_id, pbp.period ORDER BY elapsed_time_sec ASC ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS h_2FG,
  SUM(IF(is_home = 0 AND event_type = "GOOD" AND NOT three_point_shot, 1, 0)) OVER 
  (PARTITION BY pbp.game_id, pbp.period ORDER BY elapsed_time_sec ASC ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS a_2FG,
  SUM(IF(is_home = 1 AND event_type = "GOOD" AND three_point_shot, 1, 0)) OVER 
  (PARTITION BY pbp.game_id, pbp.period ORDER BY elapsed_time_sec ASC ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS h_3FG,
  SUM(IF(is_home = 0 AND event_type = "GOOD" AND three_point_shot, 1, 0)) OVER 
  (PARTITION BY pbp.game_id, pbp.period ORDER BY elapsed_time_sec ASC ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS a_3FG,
  SUM(IF(is_home = 1 AND event_type = "GOOD" and shot_type = 'FT', 1, 0)) OVER 
  (PARTITION BY pbp.game_id, pbp.period ORDER BY elapsed_time_sec ASC ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS h_FT,
  SUM(IF(is_home = 0 AND event_type = "GOOD" and shot_type = 'FT', 1, 0)) OVER 
  (PARTITION BY pbp.game_id, pbp.period ORDER BY elapsed_time_sec ASC ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS a_FT,
  SUM(IF(is_home = 1 AND event_type = "ASSIST", 1, 0)) OVER 
  (PARTITION BY pbp.game_id, pbp.period ORDER BY elapsed_time_sec ASC ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS h_ASSIST,
  SUM(IF(is_home = 0 AND event_type = "ASSIST", 1, 0)) OVER 
  (PARTITION BY pbp.game_id, pbp.period ORDER BY elapsed_time_sec ASC ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS a_ASSIST,
  SUM(IF(is_home = 1 AND event_type = "REBOUND", 1, 0)) OVER 
  (PARTITION BY pbp.game_id, pbp.period ORDER BY elapsed_time_sec ASC ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS h_REBOUND,
  SUM(IF(is_home = 0 AND event_type = "REBOUND", 1, 0)) OVER 
  (PARTITION BY pbp.game_id, pbp.period ORDER BY elapsed_time_sec ASC ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS a_REBOUND,
  SUM(IF(is_home = 1 AND event_type = "STEAL", 1, 0)) OVER 
  (PARTITION BY pbp.game_id, pbp.period ORDER BY elapsed_time_sec ASC ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS h_STEAL,
  SUM(IF(is_home = 0 AND event_type = "STEAL", 1, 0)) OVER 
  (PARTITION BY pbp.game_id, pbp.period ORDER BY elapsed_time_sec ASC ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS a_STEAL,
  SUM(IF(is_home = 1 AND event_type = "FOUL", 1, 0)) OVER 
  (PARTITION BY pbp.game_id, pbp.period ORDER BY elapsed_time_sec ASC ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS h_FOUL,
  SUM(IF(is_home = 0 AND event_type = "FOUL", 1, 0)) OVER 
  (PARTITION BY pbp.game_id, pbp.period ORDER BY elapsed_time_sec ASC ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS a_FOUL,
  SUM(IF(is_home = 1 AND event_type = "TURNOVER", 1, 0)) OVER 
  (PARTITION BY pbp.game_id, pbp.period ORDER BY elapsed_time_sec ASC ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS h_TURNOVER,
  SUM(IF(is_home = 0 AND event_type = "TURNOVER", 1, 0)) OVER 
  (PARTITION BY pbp.game_id, pbp.period ORDER BY elapsed_time_sec ASC ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS a_TURNOVER
FROM
`stardust-analysis.cloude.pbp` as pbp
JOIN (
SELECT
  box.game_id,
  box.team_code,
  home.school AS home_team,
  box.opp_code,
  away.school AS away_team
FROM
  `stardust-analysis.ncaa_mbb.team_box` AS box
JOIN
  `stardust-analysis.ncaa_mbb.team_info` AS home
ON
  home.team_code = box.team_code
JOIN
  `stardust-analysis.ncaa_mbb.team_info` AS away
ON
  away.team_code = box.opp_code
WHERE
  box.season = 2017
  AND home.division = 1
  AND home.season = 2017
  AND away.division = 1
  AND away.season = 2017
  AND period = 0
  and is_home = 1
ORDER BY
game_id ASC) AS game
ON pbp.game_id = game.game_id
ORDER BY game_id, elapsed_time_sec ASC)
SELECT
  *,
  (h_FT) + (h_2FG * 2) + (h_3FG * 3) as h_PTS,
  (a_FT) + (a_2FG * 2) + (a_3FG * 3) as a_PTS,
  (((h_FT) + (h_2FG * 2) + (h_3FG * 3)) - ((a_FT) + (a_2FG * 2) + (a_3FG * 3))) as score_differential,
  CASE 
    WHEN ((((h_FT) + (h_2FG * 2) + (h_3FG * 3)) - ((a_FT) + (a_2FG * 2) + (a_3FG * 3)))) > 0 THEN home_id
    ELSE away_id
  END AS winning_id
FROM pbp_box_stats
  WHERE
    game_id='%s'
  """ %game_id
)
games_df = games.to_dataframe()
games_df.head(3)

def running_safety_margin(game_df):
  cols = ['Time Remaining', 'Score Differential', 'Estimated Time Lead can be Held', 'Winning Team', 'Game Decided']
  lst = []
  time_score_dict = {}
  game_over = {}
  for (i, row) in game_df.iterrows():
    game_over[row['elapsed_time_sec']] = safe_lead(row['score_differential'], row['winning_id'], row['event_team_id'], row['elapsed_time_sec']) 
    time_score_dict[row['elapsed_time_sec']] = safe_margin(row['score_differential'], row['winning_id'], row['event_team_id']) 
    time_remaining = 2400-row['elapsed_time_sec']
    recovery = time_score_dict[row['elapsed_time_sec']] 
    score_differential = row['score_differential']
    winning_team = row['winning_id']
    decision = game_over[row['elapsed_time_sec']]
    lst.append([time_remaining, score_differential, recovery, winning_team, decision])
  df = pd.DataFrame(lst, columns=cols)
  return df
running_safety_margin(games_df)